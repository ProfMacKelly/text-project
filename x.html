```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Legal Decision Tree Deck</title>

  <!-- Reveal.js -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5/dist/reveal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@5/dist/theme/white.css">

  <style>
    /* Layout helpers */
    .mermaid { font-size: 20px; }

    /* Fixed UI overlay */
    .overlay-ui {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      pointer-events: none;
      z-index: 9999;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .breadcrumbs {
      pointer-events: auto;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(4px);
      font-size: 14px;
      overflow-x: auto;
      white-space: nowrap;
    }

    .crumb {
      padding: 0.2rem 0.5rem;
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 999px;
    }
    .crumb .choice {
      margin-left: 0.35rem;
      font-weight: 600;
    }

    .controls {
      position: fixed;
      left: 1rem;
      bottom: 1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      pointer-events: auto;
      z-index: 9999;
      max-width: calc(100% - 2rem);
      justify-content: flex-start;
    }

    .btn {
      border: 1px solid rgba(0,0,0,0.25);
      border-bottom-width: 2px;
      border-radius: 0.6rem;
      padding: 0.5rem 0.75rem;
      background: rgba(255,255,255,0.95);
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
      user-select: none;
    }
    .btn[disabled] {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .btn kbd {
      display: inline-block;
      border: 1px solid #888;
      border-bottom-width: 2px;
      padding: 0.05rem 0.3rem;
      border-radius: 0.25rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.9em;
      margin-left: 0.35rem;
    }

    .route-hint { font-size: 0.75em; opacity: 0.75; margin-top: 0.75rem; }

    /* Allow slides to scroll when content exceeds the viewport */
    .reveal .slides section {
      max-height: calc(100vh - 3.5rem);
      overflow-y: auto;
      padding: 1.25rem 1.5rem 4rem;
      box-sizing: border-box;
    }

    /* Summary UI */
    .summary-table{width:100%;border-collapse:collapse;margin-top:0.75rem;font-size:14px;}
    .summary-table th,.summary-table td{border:1px solid rgba(0,0,0,0.2);padding:0.5rem;vertical-align:top;}
    .muted{opacity:0.75;}
    .callout{
      margin-top:0.75rem;
      padding:0.75rem;
      border:1px solid rgba(0,0,0,0.15);
      border-radius:0.75rem;
      background:rgba(255,255,255,0.90);
      font-size:14px;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 0.95em;
    }
  </style>
</head>

<body>
  <!-- Overlay UI -->
  <div class="overlay-ui">
    <div id="breadcrumbs" class="breadcrumbs" aria-label="Branch history"></div>
  </div>

  <div class="controls" aria-label="Branch controls">
    <button id="btnSummary" class="btn" type="button" title="Summary (S)">
      Summary <kbd>S</kbd>
    </button>

    <button id="btnBack" class="btn" type="button" title="Back (B)">
      Back <kbd>B</kbd>
    </button>
    <button id="btnNo" class="btn" type="button" title="No (N)">
      No <kbd>N</kbd>
    </button>
    <button id="btnYes" class="btn" type="button" title="Yes (Y)">
      Yes <kbd>Y</kbd>
    </button>
  </div>

  <div class="reveal">
    <div class="slides">

      <!-- Title -->
      <section id="start" data-label="Start" data-yn-disabled="true">
        <h2>Legal Analysis Decision Tree</h2>
        <p>Decision slides accept <strong>Y</strong>/<strong>N</strong> (and buttons). Use <strong>B</strong> to return to the last decision. Use <strong>S</strong> for Outcome Summary.</p>
        <p class="route-hint">Press Space/→ to begin.</p>
      </section>

      <!-- SUMMARY -->
      <section id="SUMMARY" data-label="Summary" data-yn-disabled="true">
        <h2>Outcome Summary</h2>
        <p class="muted">Shows your path, the outcome (if reached), and instructor explanations for each decision point.</p>

        <div class="callout">
          <strong>Student submission</strong>
          <div style="margin-top:0.35rem;">
            When you are finished, click <em>Download submission (JSON)</em> and upload the file wherever your instructor requested (e.g., LMS assignment).
          </div>
          <div class="muted" style="margin-top:0.35rem;">
            Your submission includes your chosen pathway and outcome. It does not require your name.
          </div>
        </div>

        <div id="summaryMeta" style="margin-top:0.75rem;"></div>
        <div id="summaryOutcome" style="margin-top:0.5rem;"></div>
        <div id="summaryPath" style="margin-top:0.75rem;"></div>

        <div style="margin-top:0.75rem; display:flex; gap:0.5rem; flex-wrap:wrap;">
          <button class="btn" type="button" id="btnDownload">Download submission (JSON)</button>
          <button class="btn" type="button" id="btnReset">Reset path (session)</button>
        </div>
      </section>

      <!-- Generic Decision Slide Template -->
      <section id="Q1"
        data-label="Decision 1"
        data-yes="Q1Y"
        data-no="Q1N"
        data-feedback="Focus on how each element functions as a gate: if the element is not satisfied, the analysis typically terminates or shifts to an alternate doctrine. Emphasize that the decision should be anchored in facts and admissible inferences.">
        <h3>Decision Point</h3>

        <pre class="mermaid">
flowchart TD
  A["Question: Is Element X satisfied?"]
  A -->|Yes| B["Proceed to next element"]
  A -->|No| C["Stop / alternate doctrine"]

  class B yesPath;
  class C noPath;
        </pre>

        <p class="route-hint">Press <kbd>Y</kbd> or <kbd>N</kbd>.</p>
      </section>

      <section id="Q1Y" data-label="Element X: Yes" data-yn-disabled="true">
        <h3>Yes Branch</h3>
        <pre class="mermaid">
flowchart TD
  B[Element X satisfied] --> D[Next decision point]
  class B yesPath;
        </pre>
      </section>

      <section id="Q1N" data-label="Element X: No" data-yn-disabled="true">
        <h3>No Branch</h3>
        <pre class="mermaid">
flowchart TD
  C[Element X not satisfied] --> E[End / Different claim]
  class C noPath;
        </pre>
      </section>

      <!-- Example: Torts (Negligence chain) -->
      <section id="TORT_DUTY"
        data-label="Torts: Duty"
        data-yes="TORT_BREACH"
        data-no="TORT_END_NO_DUTY"
        data-feedback="Duty analysis is often contested: identify the source of duty (common law/statute), any special relationship, and policy limits on liability. If there is no duty, the negligence claim generally fails regardless of breach/causation/damages.">
        <h3>Torts: Duty?</h3>
        <pre class="mermaid">
flowchart TD
  A[Duty of care owed?] -->|Yes| B[Breach]
  A -->|No| C[No negligence liability]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="TORT_BREACH"
        data-label="Torts: Breach"
        data-yes="TORT_CAUSE"
        data-no="TORT_END_NO_BREACH"
        data-feedback="Breach asks whether conduct fell below the applicable standard of care. Tie the choice to concrete facts (what was done/omitted), foreseeable risks, and how a reasonable person would act under similar circumstances.">
        <h3>Torts: Breach?</h3>
        <pre class="mermaid">
flowchart TD
  A[Breach of duty?] -->|Yes| B[Causation]
  A -->|No| C[No negligence liability]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="TORT_CAUSE"
        data-label="Torts: Causation"
        data-yes="TORT_DAMAGES"
        data-no="TORT_END_NO_CAUSE"
        data-feedback="Causation typically has two parts: cause-in-fact (but-for/substantial factor) and proximate cause (scope of liability/foreseeability). Students often diverge on proximate cause—identify what fact(s) drive the foreseeability judgment.">
        <h3>Torts: Causation?</h3>
        <pre class="mermaid">
flowchart TD
  A[Cause-in-fact & proximate cause?] -->|Yes| B[Damages]
  A -->|No| C[No negligence liability]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="TORT_DAMAGES"
        data-label="Torts: Damages"
        data-yes="TORT_END_LIABILITY"
        data-no="TORT_END_NO_DAMAGES"
        data-feedback="Damages requires legally cognizable harm. Distinguish: actual loss vs. speculative harm; and whether nominal damages are available in the claim at issue. In negligence, lack of compensable damages generally ends liability.">
        <h3>Torts: Damages?</h3>
        <pre class="mermaid">
flowchart TD
  A[Legally cognizable damages?] -->|Yes| B[Negligence liability]
  A -->|No| C[No negligence liability]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="TORT_END_LIABILITY" data-label="Torts: Liability" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="All elements satisfied: negligence liability (subject to defenses).">
        <h3>Torts Outcome</h3>
        <p>All elements satisfied: negligence liability (subject to defenses).</p>
      </section>
      <section id="TORT_END_NO_DUTY" data-label="Torts: No Duty" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="No duty → no negligence liability."><h3>Torts Outcome</h3><p>No duty → no negligence liability.</p></section>
      <section id="TORT_END_NO_BREACH" data-label="Torts: No Breach" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="No breach → no negligence liability."><h3>Torts Outcome</h3><p>No breach → no negligence liability.</p></section>
      <section id="TORT_END_NO_CAUSE" data-label="Torts: No Causation" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="No causation → no negligence liability."><h3>Torts Outcome</h3><p>No causation → no negligence liability.</p></section>
      <section id="TORT_END_NO_DAMAGES" data-label="Torts: No Damages" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="No damages → no negligence liability."><h3>Torts Outcome</h3><p>No damages → no negligence liability.</p></section>

      <!-- Example: Criminal law (Mens rea gate) -->
      <section id="CRIM_MENSREA"
        data-label="Crim: Mens Rea"
        data-yes="CRIM_ACTUS"
        data-no="CRIM_END_NO_CRIME"
        data-feedback="Mens rea determines the required mental state for the offense charged. Anchor the choice to the statutory language and the best inferences from the fact pattern; identify which facts suggest intent/knowledge/recklessness/negligence (or absence thereof).">
        <h3>Criminal Law: Mens Rea?</h3>
        <pre class="mermaid">
flowchart TD
  A["Required mens rea present?"] -->|Yes| B["Actus reus + concurrence"]
  A -->|No| C["No crime (as charged)"]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="CRIM_ACTUS"
        data-label="Crim: Actus Reus"
        data-yes="CRIM_DEF"
        data-no="CRIM_END_NO_CRIME"
        data-feedback="Actus reus requires a voluntary act (or qualifying omission with a legal duty to act) plus concurrence with mens rea. Students often diverge on whether an omission qualifies—identify the duty source if you choose Yes.">
        <h3>Criminal Law: Actus Reus?</h3>
        <pre class="mermaid">
flowchart TD
  A["Voluntary act / omission duty satisfied?"] -->|Yes| B[Consider defenses]
  A -->|No| C["No crime (as charged)"]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="CRIM_DEF"
        data-label="Crim: Defenses"
        data-yes="CRIM_END_ACQUIT"
        data-no="CRIM_END_LIAB"
        data-feedback="Defenses operate as additional gates. If a complete defense applies (e.g., justification/excuse), liability may be negated even if elements are satisfied. Note the burden and the factual predicates for the defense you think applies.">
        <h3>Criminal Law: Complete Defense?</h3>
        <pre class="mermaid">
flowchart TD
  A["Complete defense proven?"] -->|Yes| B[Acquittal]
  A -->|No| C[Liability possible]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="CRIM_END_NO_CRIME" data-label="Crim: No Crime" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="Element missing → no crime (as charged)."><h3>Criminal Outcome</h3><p>Element missing → no crime (as charged).</p></section>
      <section id="CRIM_END_ACQUIT" data-label="Crim: Acquittal" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="Complete defense → acquittal."><h3>Criminal Outcome</h3><p>Complete defense → acquittal.</p></section>
      <section id="CRIM_END_LIAB" data-label="Crim: Liability" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="Elements satisfied and no complete defense → liability possible."><h3>Criminal Outcome</h3><p>Elements satisfied and no complete defense → liability possible.</p></section>

      <!-- Example: Constitutional analysis (State action gate) -->
      <section id="CON_STATE"
        data-label="Con Law: State Action"
        data-yes="CON_STANDARD"
        data-no="CON_END_PRIVATE"
        data-feedback="State action is a threshold requirement for many constitutional claims. If the conduct is purely private (with no attributable state involvement), the Constitution typically is not implicated. Identify the best facts for/against attribution.">
        <h3>Constitutional Law: State Action?</h3>
        <pre class="mermaid">
flowchart TD
  A["Government / state action?"] -->|Yes| B[Select standard of review]
  A -->|No| C[Constitution typically not implicated]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="CON_STANDARD"
        data-label="Con Law: Standard"
        data-yes="CON_APPLY"
        data-no="CON_APPLY"
        data-feedback="Selecting the standard of review frames the burden and the government’s justificatory demands. Treat the choice as a function of classification/right at issue; articulate why a given standard applies before applying it.">
        <h3>Constitutional Law: Standard of Review Chosen?</h3>
        <pre class="mermaid">
flowchart TD
  A["Pick standard: rational basis / intermediate / strict"] --> B[Apply test]
  class B yesPath;
        </pre>
        <p class="route-hint">Use → to proceed (or map Y/N to alternatives if you want).</p>
      </section>

      <section id="CON_APPLY"
        data-label="Con Law: Apply Test"
        data-yes="CON_END_UPHELD"
        data-no="CON_END_STRUCK"
        data-feedback="Applying the test means matching facts to each prong and assessing the government’s evidence. Divergence often occurs on fit/narrow tailoring and what counts as an important/compelling interest. Identify which facts drive your conclusion.">
        <h3>Constitutional Law: Test Satisfied?</h3>
        <pre class="mermaid">
flowchart TD
  A["Government meets burden under test?"] -->|Yes| B[Law upheld]
  A -->|No| C["Law struck / relief granted"]
  class B yesPath;
  class C noPath;
        </pre>
      </section>

      <section id="CON_END_PRIVATE" data-label="Con Law: No State Action" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="No state action → constitutional claim usually fails."><h3>Con Law Outcome</h3><p>No state action → constitutional claim usually fails.</p></section>
      <section id="CON_END_UPHELD" data-label="Con Law: Upheld" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="Test satisfied → law upheld."><h3>Con Law Outcome</h3><p>Test satisfied → law upheld.</p></section>
      <section id="CON_END_STRUCK" data-label="Con Law: Struck" data-yn-disabled="true"
               data-outcome="true" data-outcome-text="Test not satisfied → law struck / remedy."><h3>Con Law Outcome</h3><p>Test not satisfied → law struck / remedy.</p></section>

    </div>
  </div>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5/dist/reveal.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@5/plugin/notes/notes.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

  <script>
    /*******************************
     * CONFIG (EDIT THESE PER EXERCISE)
     *******************************/
    const SCENARIO_ID = "Scenario-001"; // e.g., "Negligence-Pistachio-01"
    // If you keep multiple exercises in one file, you can set DOCTRINE_ID explicitly.
    // If null, the code will infer doctrine from the first decision slide prefix.
    const DOCTRINE_ID = null; // e.g., "torts_negligence" | "criminal_law" | "conlaw"

    /*******************************
     * STORAGE KEYS (fail-safe)
     *******************************/
    const KEY_HISTORY = "ldt_history";        // array of { fromId, fromLabel, choice, toId, toLabel }
    const KEY_LAST_ROUTE = "ldt_last_route";  // { fromId, choice, toId }
    const KEY_SESSION_ID = "ldt_session_id";  // random UUID-like token per session

    const __memStore = Object.create(null);

    function storageGet(key) {
      try { return sessionStorage.getItem(key); }
      catch { return __memStore[key] ?? null; }
    }
    function storageSet(key, value) {
      try { sessionStorage.setItem(key, value); }
      catch { __memStore[key] = value; }
    }
    function storageRemove(key) {
      try { sessionStorage.removeItem(key); }
      catch { delete __memStore[key]; }
    }

    function loadJSON(key, fallback) {
      try {
        const raw = storageGet(key);
        if (raw == null) return fallback;
        return JSON.parse(raw);
      } catch {
        return fallback;
      }
    }
    function saveJSON(key, value) {
      try { storageSet(key, JSON.stringify(value)); }
      catch { /* ignore */ }
    }

    function loadHistory() { return loadJSON(KEY_HISTORY, []); }
    function saveHistory(hist) { saveJSON(KEY_HISTORY, hist); }

    function setLastRoute(route) { saveJSON(KEY_LAST_ROUTE, route); }
    function getLastRoute() { return loadJSON(KEY_LAST_ROUTE, null); }

    function escapeHtml(s) {
      return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    }

    function makeSessionId() {
      // Lightweight UUID-ish generator (no crypto dependency)
      const rnd = () => Math.random().toString(16).slice(2);
      return `${Date.now().toString(16)}-${rnd()}-${rnd()}`;
    }

    function getSessionId() {
      const existing = storageGet(KEY_SESSION_ID);
      if (existing) return existing;
      const sid = makeSessionId();
      storageSet(KEY_SESSION_ID, sid);
      return sid;
    }

    /*******************************
     * MERMAID + REVEAL INIT
     *******************************/
    mermaid.initialize({ startOnLoad: false, securityLevel: "loose" });

    const deck = new Reveal({
      hash: true,
      plugins: [ RevealNotes ]
    });

    deck.initialize().then(() => {
      getSessionId(); // ensure session id exists early
      renderMermaidVisible();
      updateUIForSlide(deck.getCurrentSlide());
      renderBreadcrumbs();
      if (deck.getCurrentSlide()?.id === "SUMMARY") renderSummary();
    });

    deck.on("slidechanged", (ev) => {
      renderMermaidVisible();
      updateUIForSlide(ev.currentSlide);
      renderBreadcrumbs();
      if (ev.currentSlide?.id === "SUMMARY") renderSummary();
    });

    function renderMermaidVisible() {
      const slide = deck.getCurrentSlide();
      if (!slide) return;

      const blocks = slide.querySelectorAll("pre.mermaid:not([data-rendered='true'])");
      blocks.forEach(async (block) => {
        const code = block.textContent;
        const id = "mmd_" + Math.random().toString(16).slice(2);

        try {
          const { svg } = await mermaid.render(id, code);
          const container = document.createElement("div");
          container.innerHTML = svg;
          block.replaceWith(container);
          container.setAttribute("data-rendered", "true");
        } catch (e) {
          console.error("Mermaid render error:", e);
        }
      });
    }

    /*******************************
     * CONTROLS (Y/N + Back + Summary)
     *******************************/
    const btnYes = document.getElementById("btnYes");
    const btnNo  = document.getElementById("btnNo");
    const btnBack = document.getElementById("btnBack");
    const btnSummary = document.getElementById("btnSummary");
    const btnDownloadDeck = document.getElementById("btnDownloadDeck");
    const btnCopyDeck = document.getElementById("btnCopyDeck");

    btnYes.addEventListener("click", () => route("yes"));
    btnNo.addEventListener("click", () => route("no"));
    btnBack.addEventListener("click", () => goBackToLastDecision());
    btnSummary.addEventListener("click", () => gotoSummary());
    if (btnDownloadDeck) btnDownloadDeck.addEventListener("click", () => downloadDeck());
    if (btnCopyDeck) btnCopyDeck.addEventListener("click", () => copyDeckHtml());

    document.addEventListener("keydown", (ev) => {
      const target = ev.target;
      const tag = target?.tagName?.toLowerCase();
      const isFormField = tag === "input" || tag === "textarea" || tag === "select" || target?.isContentEditable;
      if (isFormField) return;

      const k = ev.key.toLowerCase();
      const stop = () => { ev.preventDefault(); ev.stopPropagation(); };

      if (k === "y") { stop(); route("yes"); return; }
      if (k === "n") { stop(); route("no"); return; }
      if (k === "b") { stop(); goBackToLastDecision(); return; }
      if (k === "s") { stop(); gotoSummary(); return; }
      if (k === "x") { stop(); toggleBlackout(); return; }
      if (k === "d") { stop(); downloadDeck(); return; }
      if (k === "c") { stop(); copyDeckHtml(); return; }
    }, true);

    function gotoSummary() {
      window.location.hash = "#/SUMMARY";
    }

    function toggleBlackout() {
      // Mirror Reveal.js pause/blank toggle (default on "B"), but mapped to "X" here.
      deck.togglePause();
    }

    async function copyDeckHtml() {
      if (!btnCopyDeck) {
        console.warn("Copy deck button is not present in the DOM.");
        return;
      }

      const originalLabel = btnCopyDeck.innerHTML;
      const html = "<!doctype html>\n" + document.documentElement.outerHTML;

      try {
        await navigator.clipboard.writeText(html);
        btnCopyDeck.textContent = "Copied!";
      } catch (err) {
        console.error("Copy failed:", err);
        btnCopyDeck.textContent = "Copy failed";
      }

      setTimeout(() => { btnCopyDeck.innerHTML = originalLabel; }, 1800);
    }

    function isDecisionSlide(slide) {
      if (!slide) return false;
      if (slide.dataset.ynDisabled === "true") return false;
      return !!(slide.dataset.yes && slide.dataset.no);
    }

    function updateUIForSlide(slide) {
      const decision = isDecisionSlide(slide);
      btnYes.disabled = !decision;
      btnNo.disabled  = !decision;
      btnBack.disabled = loadHistory().length === 0;
    }

    function getSlideLabelById(id) {
      const el = document.getElementById(id);
      if (!el) return id;
      return el.dataset.label || id;
    }

    function route(choice) {
      const slide = deck.getCurrentSlide();
      if (!isDecisionSlide(slide)) return;

      const fromId = slide.id;
      const fromLabel = slide.dataset.label || fromId;

      const toId = (choice === "yes") ? slide.dataset.yes : slide.dataset.no;
      if (!toId || !document.getElementById(toId)) return;

      const toLabel = getSlideLabelById(toId);

      const hist = loadHistory();
      hist.push({ fromId, fromLabel, choice, toId, toLabel });
      saveHistory(hist);

      setLastRoute({ fromId, choice, toId });

      window.location.hash = "#/" + toId;
    }

    /*******************************
     * BREADCRUMBS
     *******************************/
    function renderBreadcrumbs() {
      const bc = document.getElementById("breadcrumbs");
      const hist = loadHistory();

      bc.innerHTML = "";

      const title = document.createElement("span");
      title.style.fontWeight = "600";
      title.textContent = "Path:";
      bc.appendChild(title);

      if (hist.length === 0) {
        const empty = document.createElement("span");
        empty.style.opacity = "0.7";
        empty.style.marginLeft = "0.5rem";
        empty.textContent = "—";
        bc.appendChild(empty);
        return;
      }

      hist.forEach((h) => {
        const pill = document.createElement("span");
        pill.className = "crumb";
        pill.textContent = h.fromLabel;

        const ch = document.createElement("span");
        ch.className = "choice";
        ch.textContent = (h.choice === "yes") ? "Y" : "N";
        pill.appendChild(ch);

        bc.appendChild(pill);
      });
    }

    /*******************************
     * BACK
     *******************************/
    function goBackToLastDecision() {
      const hist = loadHistory();
      if (hist.length === 0) return;

      const last = hist.pop();
      saveHistory(hist);
      storageRemove(KEY_LAST_ROUTE);

      if (last?.fromId && document.getElementById(last.fromId)) {
        window.location.hash = "#/" + last.fromId;
      }

      renderBreadcrumbs();
      btnBack.disabled = hist.length === 0;
    }

    /*******************************
     * SUMMARY + SUBMISSION EXPORT
     *******************************/
    function computeReachedOutcome() {
      const current = deck.getCurrentSlide();
      if (current?.dataset?.outcome === "true") return current;

      const hist = loadHistory();
      if (hist.length === 0) return null;

      const last = hist[hist.length - 1];
      const candidate = document.getElementById(last.toId);
      if (candidate?.dataset?.outcome === "true") return candidate;

      return null;
    }

    function inferDoctrineIdFromHistory(hist) {
      if (DOCTRINE_ID) return DOCTRINE_ID;
      if (!hist || hist.length === 0) return "mixed";

      const first = hist[0]?.fromId || "";
      if (first.startsWith("TORT_")) return "torts_negligence";
      if (first.startsWith("CRIM_")) return "criminal_law";
      if (first.startsWith("CON_"))  return "constitutional_law";
      return "mixed";
    }

    function getStaticFeedbackForDecisionSlide(fromId) {
      const el = document.getElementById(fromId);
      return el?.dataset?.feedback ?? "";
    }

    function renderSummary() {
      const hist = loadHistory();
      const outcomeEl = document.getElementById("summaryOutcome");
      const pathEl = document.getElementById("summaryPath");
      const metaEl = document.getElementById("summaryMeta");

      const doctrineId = inferDoctrineIdFromHistory(hist);
      const sessionId = getSessionId();

      metaEl.innerHTML = `
        <div class="muted">
          <strong>Scenario:</strong> <span class="mono">${escapeHtml(SCENARIO_ID)}</span>
          &nbsp;&nbsp; <strong>Doctrine:</strong> <span class="mono">${escapeHtml(doctrineId)}</span>
          &nbsp;&nbsp; <strong>Session:</strong> <span class="mono">${escapeHtml(sessionId)}</span>
        </div>
      `;

      const outcomeSlide = computeReachedOutcome();
      const outcomeText =
        outcomeSlide?.dataset?.outcomeText ||
        outcomeSlide?.querySelector("p")?.textContent ||
        null;

      outcomeEl.innerHTML = outcomeText
        ? `<div><strong>Outcome:</strong> ${escapeHtml(outcomeText)}</div>`
        : `<div class="muted"><strong>Outcome:</strong> In progress (no terminal outcome reached yet).</div>`;

      if (hist.length === 0) {
        pathEl.innerHTML = `<p class="muted">No decisions recorded yet. Navigate to a decision slide and press Y/N.</p>`;
      } else {
        const rows = hist.map((h, idx) => {
          const note = getStaticFeedbackForDecisionSlide(h.fromId);
          return `
            <tr>
              <td>${idx + 1}</td>
              <td>${escapeHtml(h.fromLabel || h.fromId)}</td>
              <td>${h.choice === "yes" ? "Y" : "N"}</td>
              <td>${escapeHtml(h.toLabel || h.toId)}</td>
              <td>${escapeHtml(note)}</td>
            </tr>`;
        }).join("");

        pathEl.innerHTML = `
          <table class="summary-table">
            <thead>
              <tr>
                <th>#</th>
                <th>Decision</th>
                <th>Choice</th>
                <th>Next</th>
                <th>Instructor explanation</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>`;
      }

      // Wire buttons once
      const dl = document.getElementById("btnDownload");
      if (dl && dl.dataset.wired !== "true") {
        dl.dataset.wired = "true";
        dl.addEventListener("click", downloadSubmissionJSON);
      }
      const reset = document.getElementById("btnReset");
      if (reset && reset.dataset.wired !== "true") {
        reset.dataset.wired = "true";
        reset.addEventListener("click", resetSession);
      }
    }

    function buildSubmissionPayload() {
      const hist = loadHistory();
      const doctrineId = inferDoctrineIdFromHistory(hist);
      const outcomeSlide = computeReachedOutcome();

      return {
        scenarioId: SCENARIO_ID,
        doctrineId,
        sessionId: getSessionId(),
        completedAt: new Date().toISOString(),
        outcome: outcomeSlide ? {
          id: outcomeSlide.id,
          label: outcomeSlide.dataset.label || outcomeSlide.id,
          text: outcomeSlide.dataset.outcomeText || outcomeSlide.querySelector("p")?.textContent || ""
        } : null,
        history: hist
      };
    }

    function downloadSubmissionJSON() {
      const payload = buildSubmissionPayload();

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);

      // Filename includes scenario + doctrine + session for easy aggregation
      const safe = (s) => String(s).replaceAll(/[^a-zA-Z0-9._-]/g, "_");
      a.download = `submission_${safe(payload.scenarioId)}_${safe(payload.doctrineId)}_${safe(payload.sessionId)}.json`;

      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 500);
    }

    async function downloadDeck() {
      const url = new URL(window.location.href);
      url.hash = ""; // fetch the raw HTML, not the hash view

      try {
        const res = await fetch(url.toString());
        const text = await res.text();
        const blob = new Blob([text], { type: "text/html" });

        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "decsion_tree_with_feedback.html";
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 500);
      } catch (e) {
        console.error("Deck download failed", e);
      }
    }

    function resetSession() {
      storageRemove(KEY_HISTORY);
      storageRemove(KEY_LAST_ROUTE);
      // keep session id stable unless you want a new one each attempt; comment out next line to keep stable
      // storageRemove(KEY_SESSION_ID);

      renderBreadcrumbs();
      renderSummary();
      updateUIForSlide(deck.getCurrentSlide());
    }
  </script>
</body>
</html>